---
layout: post
categories: posts, tutorial
title: Работа с многопоточностью в Android [Перевод]
tags: [ translate, Java, Android, multithreading]
date-string: ДЕКАБРЬ 20, 2019
featured-image: /images/2020-02-14/cover.png

---

# Введение

Эта статья является переводом (заметки)[https://medium.com/better-programming/threading-in-android-129b8688436a]

Каждый разработчик, в том или ином виде, сталкивался с необходимостью работы с потоками в их программе. Обычно, от потока требуется три вещи: стартовать, выполнить какую-то задачу, уничтожиться. 

Такое поведение подходит для небольших задач, но не подходит для длительных по времени задач, когда необходима долгая работа.

Поскольку поток умирает после выполнения необходимой части работы, часто требуется создавать циклы цель которых только в поддержании работоспособности потока. Но должна также сохраняться возможность остановить поток, когда это необходимо. 

К тому же иногда требуется некоторая очередь, обрабатываемая в цикле. Также нам может понадобиться еще один поток, который бы добавлял задачи в очередь потоков, для выполнения. 

Выполнения всего комплекса операций, работа с состояниями потоков вызывает множество непределенностей. Но все эти возможности реализованы в Android в виде откдельных классов. 

# Android Поток 

Когда приложение запускается вместе с ним создается обычный Linux-процесс. Внутри системы это создает поток выполнения для этого приложения, называемый *основным потоком* или  UI-потоком (интерфейсным потоком). Основной поток по сути представляет собой обработчик потоков. Основной поток отвечает за обработку событий происходящий в приложении, такие как, например, коллбэки связанные с жизненным циклом элементов приложения или коллбэки связанные с событиями ввода. Также возможна обработка событий связанных с другими приложениями. 

Любой блок кода, который необходимо запустить должен быть размещен в очереди на выполнение, после чего он будет выполнен в основном потоке. Поскольку основной поток берет на себя столько различных операций, длительные по времени операции лучше проводить в других потоках, что бы не задерживать основной. Важно избегать использование основного потока для длительных операций, что бы не ввести приложение в состояние ПНО (*Приложение не отвечает - Application Not Responce*). 

Сетевые операции или запросы к базам данных, загрузка каких-то компонентов или другие схожие операции могут вызвать *состояние блокирования* основного потока приложения. Это значит, что пока некоторый длительный процесс не завершиться, пользовательский интерфейс, отрисовывающийся в основном потоке, также не будет отвечать. Что бы избегать таких ситуаций, такие операции выносят в отдельные потоки. Это значит, что они выполнятся асинхронно от пользовательского интерфейса.

Android предлает несколько вариантов создания и управления потоками, а также множество сторонних библиотек, которые делают управление потоками проще. Каждый вид потоков предназначен для какой-то определенной цели и выбор правильного потока, соответствующего задаче, очень важен.

Доступны следующие классы-потоки:

- **AsyncTask**: Помогает работать с UI-потоком
- **HandlerThread**: Поток для обратных вызовов
- **ThreadPoolExecutor**: Запускает множество параллельных потоков
- **IntentService**: Помогает получить намерение (intent) от UI-потока

# AsyncTask

AsyncTask позволяет проще работать с интерфейсом из другого потока. Этот класс позволяет выполнять фоновые операции в отдельном потоке и отображать их результаты в потоке интерфейса без использования дополнительных обработчиков. 

AsyncTask проектировался как класс-помощник для Thread и Handler и не является универсальным потоком для любых задач. AsyncTask, в идеале, необходимо использовать для быстрых операций, которые слишком тяжелы для основного потока (максимум несколько секунд). Если необходимо выполнять какую-то опрацию в потоке длительное время рекомендуется использовать различные АПИ из пакета `java.util.concurrent`, такие как `Executor`, `ThreadPoolExeutor`, `FutureTask`. 

Когда асинхронная задача обрабатываются, выполняются следующие четыре шага: 

1. `onPreExecute()`: Вызывается в потоке пользовательского интерфейса, перед выполнением основной задачи. Обычно используется для того что бы выполнить что-то перед запуском процесса вычислений, например, показывает уведомление о начале процесса в пользовательском интерфейсе. 
2. `doInBackground(Params...)`: Вызывается в фоновом потоке, после `onPreExecute()`. Этот шаг выполняет фоновые вычисления, которые могут длиться продолжнительное время. Параметры асинхронной задачи передаются на этом шаге. Результат вычислений вызвращается на этом шаге и отправляется в `onPostExecute()`. На этом шаге также можно использовать `publishProgress(..)` для уведомления других потоков о статусе выполнения задачи. 
3. `onProgressUpdate(Progress…)`: Вызывается в потоке пользовательского интерфейса, после вызова `publishProgress(..)`. Этот метод используется для показа прогресса процесса в любой форме в пользовательском интерфейсе, пока фоновая задача выполняется. Например, это может быть использовано для анимации полосы прогресса или отображения в лог-файлах. 
4. `onPostExecute(Result)`: Вызывается в потоке пользовательского интерфейса, после того как фоновая задача завершится. Результат вычислений может быть передан в этот шаг, как параметр.


Выполнение задачи может быть остановлено с любой момент при помощи вызова `cancel(boolean...)`. Перед вызовом отмены выполнения потока, нужно убедиться, что поток запущен. 

## Реализация

```java
private class AsyncTaskRunner extends AsyncTask<String, String, String> {
@Override  
protected void onPreExecute() {
    progressDialog.show();
 }
@Override  
protected String doInBackground(String... params) {          
    doSomething();
    publishProgress("Sleeping..."); // вызывывает onProgressUpdate()
    return resp;
 }
@Override   protected void onPostExecute(String result) {
    // результат выполнения долгой операции 
    progressDialog.dismiss();
    updateUIWithResult() ;
 }
@Override  
protected void onProgressUpdate(String... text) {
    updateProgressUI();
 }
}
```
## Когда использовать AsyncTask 

AsyncTask практически идеален в тех ситуациях, когда нам нужно выполнить недлительную операцию и быстро вернуть результат, часто обновляя пользовательский интерфейс. 

Однако, асинхронные задачи, прекращают свое выполнение, когда прекращает жизненный цикл активность/фрагмент. Иногда, даже поворот экрана может привести к прерыванию выполнения задачи. 

## Порядок выполнения

По-умолчанию, все созданные асинхронные задачи, будут работать из одного потока и выполняться последовательно в одной очереди сообщений. Иногда такой подход может повлиять на выполняемые задачи. Если нам необходимо параллельное выполнение, можно использовать `THREAD_POOL_EXECUTOR` (прим. `AsyncTask.THREAD_POOL_EXECUTOR`). 
